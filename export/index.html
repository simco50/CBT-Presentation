<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Concurrent Binary Tree</title>

  <meta name="description" content="">
  <meta name="author" content="">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- REVEAL CSS-->
  <link rel="stylesheet" href="libs/reveal.js/font-awesome-4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="libs/reveal.js/3.8.0/css/reveal.css">
  
  <link rel="stylesheet" href="libs/reveal.js/3.8.0/css/theme/Blood.css" id="theme">
  
  
  <link rel="stylesheet" href="libs/reveal.js/3.8.0/plugin/title-footer/title-footer-mod.css" />

  <!-- MERMAID-->
  <script src="libs/reveal.js/3.8.0/plugin/mermaid/mermaid.min.js"></script>
  <style>
  .mermaid {
    font-size: 0.5em;
  }
  </style>

  <style>
    [class*=task-list-item] {
    min-height: 22px;
    margin-top: 6px!important;
    margin-bottom: 6px!important;
    padding-left: 0;
    list-style: none;
}

[class*=task-list-item]>input:first-child {
    position: absolute!important;
    opacity: 0;
    margin: 0;
}
[class*=task-list-item]>label {
    padding-left: 29px!important;
    min-height: 22px;
    line-height: 22px;
    display: inline-block;
    position: relative;
    vertical-align: top;
    margin-bottom: 0;
    font-weight: 400;
    cursor: pointer;
}

.task-list-item>input:first-child:checked+input[type=hidden]+label::before, .task-list-item>input:first-child:checked+label::before {
    background-color: #ecf0f1;
    border-color: #ecf0f1;
}

[class*=task-list-item]>input:first-child+input[type=hidden]+label::before, [class*=task-list-item]>input:first-child+label::before {
    content: "";
    display: inline-block;
    position: absolute;
    width: 22px;
    height: 22px;
    border: 1px solid #D3CFC8;
    border-radius: 0;
    margin-left: -29px;
}


[class*=task-list-item]>input:first-child:checked+input[type=hidden]+label::after, [class*=task-list-item]>input:first-child:checked+label::after {
    content: "";
    display: inline-block;
    position: absolute;
    top: 0;
    left: 0;
    width: 7px;
    height: 10px;
    border: 2px solid #fff;
    border-left: none;
    border-top: none;
    transform: translate(7.75px,4.5px) rotate(45deg);
    -ms-transform: translate(7.75px,4.5px) rotate(45deg);
}


.task-list-item>input:first-child:checked+input[type=hidden]+label::after, .task-list-item>input:first-child:checked+label::after {
    border-bottom-color: #95a5a6;
    border-right-color: #95a5a6;
}
  </style>

  <!-- Theme used for syntax highlighting of code -->
  
  <link rel="stylesheet" href="libs/highlight.js/9.12.0/monokai.css">
  

  
  
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'libs/reveal.js/3.8.0/css/print/pdf.css' : 'libs/reveal.js/3.8.0/css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <style>
    /* Solarized Light theme */
     .line {
      display: block;
    }
    

    .line.focus {
      background: #fdf6e3;
      color: #657b83;
    }

/*
    .line.focus .hljs-comment,
    .line.focus .hljs-quote {
      color: #93a1a1;
    }

    .line.focus .hljs-keyword,
    .line.focus .hljs-selector-tag,
    .line.focus .hljs-addition {
      color: #859900;
    }

    .line.focus .hljs-number,
    .line.focus .hljs-string,
    .line.focus .hljs-meta .hljs-meta-string,
    .line.focus .hljs-literal,
    .line.focus .hljs-doctag,
    .line.focus .hljs-regexp {
      color: #2aa198;
    }

    .line.focus .hljs-title,
    .line.focus .hljs-section,
    .line.focus .hljs-name,
    .line.focus .hljs-selector-id,
    .line.focus .hljs-selector-class {
      color: #268bd2;
    }

    .line.focus .hljs-attribute,
    .line.focus .hljs-attr,
    .line.focus .hljs-variable,
    .line.focus .hljs-template-variable,
    .line.focus .hljs-class .hljs-title,
    .line.focus .hljs-type {
      color: #b58900;
    }

    .line.focus .hljs-symbol,
    .line.focus .hljs-bullet,
    .line.focus .hljs-subst,
    .line.focus .hljs-meta,
    .line.focus .hljs-meta .hljs-keyword,
    .line.focus .hljs-selector-attr,
    .line.focus .hljs-selector-pseudo,
    .line.focus .hljs-link {
      color: #cb4b16;
    }

    .line.focus .hljs-built_in,
    .line.focus .hljs-deletion {
      color: #dc322f;
    }

    .line.focus .hljs-formula {
      background: #eee8d5;
    }

    .line.focus .hljs-emphasis {
      font-style: italic;
    }

    .line.focus .hljs-strong {
      font-weight: bold;
    }

    .yellow-slide .line.focus:nth-child(2) {
      background: yellow;
    }

    .reveal .slides section .code-presenting-annotation {
      font-size: 70%;
    }
    */

    .reveal .slides section .fragment.current-only {
      visibility: visible;
      display: none;
    }

    .reveal .slides section .fragment.current-only.current-fragment {
      display: block;
    }

/*
    .line {
      display: block;
    }
*/
    .line.focus {
       opacity: 1.0;
    } 

    /* .hljs {
      background: none;
    } */

    /* .reveal pre {
      width: 98%;
      margin: 0px;
      box-shadow: none;
    }

    .reveal pre code {
      font-size: 1.2em;
      line-height: 1.2;
      border-radius: 10px;
      max-height: 60vh !important;
      overflow: hidden !important;
    } */

    @media (device-width: 100vw) and (device-height: 100vh) {
      .reveal pre code {
        max-height: 50vh !important;
      }
    }

    #logo img {
      max-height: 3.5em;
      max-width: none;
      min-width: 50px;
    }

    .reveal .slides section .code-presenting-annotation {
      color: white;
      background: black;
      padding: 0px 15px;
      border-radius: 15px;
      opacity: 0.75 !important;
      font-size: 50% !important;
    }
  </style>
  <script>
    if (window.location.search.match(/print-pdf-now/gi)) {
      window.print();
    }
  </script>
</head>

<body>
  

  <div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">

      


    
        <section data-background-video="resources/CBT_Main.mp4" data-background-color="#000000">
            
            <!-- .slide: data-background-video="resources/CBT_Main.mp4" data-background-color="#000000" -->
<h3><a id="user-content-adaptive-subdivion-on-the-gpu" class="anchor" href="#adaptive-subdivion-on-the-gpu" aria-hidden="true"></a>Adaptive Subdivion on the GPU</h3>
<h5><a id="user-content-concurrent-binary-tree--longest-edge-bisection" class="anchor" href="#concurrent-binary-tree--longest-edge-bisection" aria-hidden="true"></a>Concurrent Binary Tree &amp; Longest Edge Bisection</h5>
<aside class="notes"> Hello everyone. A couple months ago, I attended virtual SIGGRAPH and while there was a ton of interesting content and talks, there was one in particular that really got my attention which was a presentation by some graphics engineers at Unity who have implemented terrain rendering with adaptive subdivion inside Unity with this novel data structure called a Concurrent Binary Tree.
After seeing the presentation and later reading the paper, I decided to try and implement this myself based on the paper and what you see here in the background is the result the implementation, though as you can see no artistic touch whatsoever :).
So based on those results and findings, I’d like to talk about adaptive subdivision on the GPU using concurrent binary trees and longest edge bisection.
The title is quite a mouthful of words, but I wouldn’t worry, because it’s actually not as complicated as it sounds and I hope that when I finish talking you’ll understand how it works.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-manim" class="anchor" href="#manim" aria-hidden="true"></a>Manim</h3>
<p><a href="https://www.youtube.com/watch?v=ocVSfWo3MLY"><em>video source</em></a></p>
<video src="Resources/Bubble Sort Demo.mp4">
<aside class="notes"> Before I jump in. I recently found out, just when I started making this presentation, that the library used to make math instructional videos by 3Blue1Brown, with which you may be familiar with, is an open source Python library called Manim.
I decided to play around with it and I ended up implementing a part of the subdivision algorithms in Python to be able to visualize them.
I think this library is super cool and the video here is just and example I took from YouTube to show you what it can do.</aside>

            </section>
    



    
        <section >
            
            <h2><a id="user-content-skip-to-the-results" class="anchor" href="#skip-to-the-results" aria-hidden="true"></a>Skip to the results</h2>
<aside class="notes"> So moving on, let’s jump into it. Like I said, the title of this presentation is quite the mouthful so I’d like to start with a little demo first to give you an idea of what exactly we try to achieve here.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-loads-of-material" class="anchor" href="#loads-of-material" aria-hidden="true"></a>Loads of material!</h3>
<h4><a id="user-content-jonathan-dupuy" class="anchor" href="#jonathan-dupuy" aria-hidden="true"></a><a href="(https://onrendering.com/)">Jonathan Dupuy</a></h4>
<p><img src="Resources/PaperCover.png" alt=""></p>
<aside class="notes"> All of this work is almost entirely based on the work of Jonathan Dupuy, who’s a research engineer at Unity. If you want to learn more about this tech, I highly recommend checking out his initial presentation about it on YouTube</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-adaptive-subdivision" class="anchor" href="#adaptive-subdivision" aria-hidden="true"></a>Adaptive Subdivision</h3>
<p>Tessellation shaders, Geometry shaders?</p>
<p>Subdivision = Recursive Algorithm = Exponential Cost</p>
<ul>
<li>Adaptive: Subdivide where necessary</li>
<li>Parallel: Multithreaded, on GPU</li>
</ul>
<aside class="notes"> Subdivision is a pretty well researched topic in computer graphics and ranges a huge amount of techniques going from very simple to pretty complicated stuff.
It is a recursive algorithm which fundamentally makes it exponential in computation cost.
There’s a few available options around there like the Tessellation Shader but for those who are familiar with it, it doesn’t have good performance, doesn’t produce good topology and still isn’t well supported on certain platforms.
Essentially what we want is to be able to amortize the exponential cost by subdividing adaptively, in parallel and over several frames.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-subdivision-as-binary-trees" class="anchor" href="#subdivision-as-binary-trees" aria-hidden="true"></a>Subdivision as Binary Trees</h3>
<p>Leaf nodes describe triangles via the path they form from the root</p>
<video src="Resources/renders/hq/UniformLEB_WithTree_Main.mp4">
<aside class="notes"> This brings me to the idea proposed in the paper. The canonical subdivision can be represented with a binary tree with each level of the tree representing a subdivision level. Think about the root node being a single large triangle and splitting the triangle is done by splitting the node in two children.
This means, if we find a way to parallelize operating on the nodes of a binary tree, we can accelerate our subdivision.
In other words, what we want, is to be able to process each node in the binary tree indepedently on the GPU by either spliting it or merging it without terrible data access conflicts.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-longest-edge-bisection-leb" class="anchor" href="#longest-edge-bisection-leb" aria-hidden="true"></a>Longest Edge Bisection (LEB)</h4>
<aside class="notes"> I’d like to split the problem in two parts: Rendering the triangles represented in the binary tree, and update the binary tree efficiently based on a ruleset. And that ruleset effectively boils down to adding more detail the closer the camera is to the triangle. I’m going to start by described the approach to render the triangles first. For this an algorithm called Longest Edge Bisection is used.</aside>

            </section>
    



    
        <section >
            
            <p>Uniform Subdivision</p>
<video src="Resources/renders/hq/UniformLEB_NoTree_Main.mp4">
<aside class="notes"> Longest Edge Bisection (or LEB for short) is a fancy name for possibly the simplest subdivision scheme in existance. You take a triangle and you split it in half along it’s longest edge leaving you with 2 triangles. And this can be done recursively to achieve more subdivision.
This fits exactly with the binary tree idea.
For uniform subdivision, each subdivision, the amount of triangles will double due to its exponential nature.
As you can see in the video, we assign each triangle a value starting from 1 which match the binary tree indices starting from the root not of the tree.</aside>

            </section>
    



    
        <section >
            
            <p>Binary</p>
<video src="Resources/renders/hq/UniformLEB_Binary_Main.mp4">
<aside class="notes"> Now let’s look at this again but show each triangle value’s in it’s binary representation.
There’s two convenient things we see here. The subdivision depth of each triangle is defined by the number of bits of the index.
And the least significant bit - or rightmost bit - defines if the triangle gets split to the left side or the right side.</aside>

            </section>
    



    
        <section >
            
            <p>LEB Split Matrix</p>
<video src="Resources/renders/hq/LEBMatrices_Main.mp4">
<aside class="notes">
With these two observations in mind, the subdivision algorithm can be implemented per triangle by scanning over all the bits in the index of the triangle and recursively multiplying a so called split matrix based on if that bit is a 0 or a 1.
The left matrix above scales and shifts the triangle vertices to the left side, and the right matrix does the same but for the right side.
It doesn’t take long to realize both are almost identical and we can just plug in a parameter based on the bit value
So the almost the entire algorithm is done with this single matrix.</aside>

            </section>
    



    
        <section >
            
            <p>Example</p>
<aside class="notes"> I can understand all of this may still sound a bit abstract but I think a concrete example will make it clear how it works and make you realize how simple this actually is.</aside>

            </section>
    



    
        <section >
            
            <video src="Resources/renders/hq/LEBBitScan_Demo1.mp4">
<aside class="notes"> So let’s say we want the vertices of the triangle with value 39. This has the binary representation 100111. We start with an identity matrix. We scan the binary value starting from the most significant bit, grab the appropriate split matrix based on if it’s a 0 or a 1, and multiply it with the previous matrix. Once that’s done, you’re left with a matrix you can multiply with the base triangle and those are the vertex positions of the triangle which are shown in the top right.</aside>

            </section>
    



    
        <section >
            
            <p>Another!</p>
<video src="Resources/renders/hq/LEBBitScan_Demo2.mp4">
<aside class="notes"> Here is another example, let’s take triangle 52 to confirm this algorithm is independent of which triangle you pick.
Again, start with the base triangle and an identity matrix, scan each bit from MSB to LSB and multiply by the appropriate split matrix. Then multiply the base triangle with the composed matrix and that’s it.</aside>

            </section>
    



    
        <section >
            
            <p>Adaptive Subdivision</p>
<video src="Resources/renders/hq/AdaptiveLEB_NoTree_Main.mp4">
<aside class="notes"> Now I think that’s pretty elegant and it’s not that hard to make this adaptive. Adaptive subdivision has essentially the same principles but we subdivide our triangle based on a target criteria, for example this point.
When recursively check if the target is inside the triangle and if it is, we split it.
Notice that the following video actually has a problem, partially due to procrastinating making this presentation and therefor having too little time but also to prove a point, which is that it creates so called T-juctions which are the vertices touching the middle of an edge and that could cause cracks in the geometry. Image there being a height offset at that point, there is no way for that larger triangle to match the deformation of its neighboring triangles. We want to avoid that.</aside>

            </section>
    



    
        <section >
            
            <video width="650px" src="Resources/AdaptiveLEB.mp4">
<aside class="notes"> So here with a video capture in application where this problem is solved. We do this by making sure a neighboring triangle is never more than 1 level different in subdivision. This can be implemented by adapting the splitting and merging operation during subdivision.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-binary-tree" class="anchor" href="#binary-tree" aria-hidden="true"></a>Binary Tree</h3>
<video src="Resources/renders/hq/AdaptiveLEB_WithTree_Main.mp4">
<aside class="notes"> So going back to the idea from the start, because the LEB algorithm splits the triangle in two, it can be associated with our binary tree with the triangles being leaf nodes of the tree. Splitting a triangle in two then means splitting the node into two children.
So we now have the algorithm to be able to render the triangles described by a binary tree representing subdivision.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-concurrent-binary-tree" class="anchor" href="#concurrent-binary-tree" aria-hidden="true"></a>“Concurrent” Binary Tree</h3>
<video src="Resources/renders/hq/BinaryTree_ExampleTree.mp4">
<aside class="notes"> So this is the main subject of the paper which is the novel data structure which allows updating of a binary tree in parallel.
Manipulating a regular binary tree data structure in parallel is not efficient so that’s where CBT comes in.
In essence, a Concurrent Binary Tree (or CBT) looks like a binary tree but it actually encodes a binary tree.
It’s formed of 2 parts: a bitfield with bits equal to the amount of maximum leaf nodes and a sum reduction tree which stores the sum of child node values from bottom to top.
The bitfield alone can actually represent the binary tree but the sum reduction tree will become a key part to be able to parallize the workloads. The bitfield is encoded as 32 bit integers because we can’t represent or modify individual bits.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-encoding-a-binary-tree-with-a-bitfield" class="anchor" href="#encoding-a-binary-tree-with-a-bitfield" aria-hidden="true"></a>Encoding a binary tree with a bitfield</h4>
<video src="Resources/renders/hq/BitfieldToTree_Main.mp4">
<aside class="notes"> The bitfield alone encodes the entire binary tree. The way that works is that each one in the bitfield represents a leaf node.
Take for example the last bit here, to compute which node it’s associated with, we simply count the number of zero’s that come after it, add one and take the log2 of that. The result is 2 which means that starting from the bottom, we go 2 layers up and reach index 3.
That means a fully split binary tree is just a bitfield with all 1’s and a binary tree with a single node is just a single 1 with all 0’s.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-splitting-and-merging" class="anchor" href="#splitting-and-merging" aria-hidden="true"></a>Splitting and merging</h4>
<p>Split node 3 and merge node 4.</p>
<p><img src="Resources/Example_SubDiv_01.png" alt=""></p>
<aside class="notes"> What makes this so powerful is that we can describe node splitting as setting the right child bit to 1 and node merging as setting the right child bit to 0. This can be done in parallel as long as these modifications are done with atomic operations like InterlockedOr and InterlockedAnd.
Take this tree for example.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-split" class="anchor" href="#split" aria-hidden="true"></a>Split</h4>
<p>Set right child bit to 1</p>
<p><img src="Resources/Example_SubDiv_Split.png" alt=""></p>
<aside class="notes"> To split for example node 3, we simply take the right child node, get its corresponding bit and set that to 1.
See how the left child index is always 2 times the node index and the right child index is that plus one. So this is super fast to compute.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-merge" class="anchor" href="#merge" aria-hidden="true"></a>Merge</h4>
<p>Set right child bit to 0</p>
<p><img src="Resources/Example_SubDiv_Merge.png" alt=""></p>
<aside class="notes"> Node merging is very similar. Take the right child node, and set its corresponding bit to 0.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-sum-reduction-tree" class="anchor" href="#sum-reduction-tree" aria-hidden="true"></a>Sum Reduction Tree</h3>
<p>Map ThreadID -&gt; Triangle</p>

            </section>
    



    
        <section >
            
            <p><img src="Resources/BinarySearch_Example_01.png" alt=""></p>
<aside class="notes"> So the bitfield encodes the binary tree and we can implement splitting and merging by setting the corresponding bit to either 1 or 0 respectively.
Now when we have a binary tree with let’s say 12 leaf nodes, we have to dispatch a shader with 12 GPU threads to process each nodes.
We’ll need an efficient way to associate each GPU thread with a leaf node. Say we’re looking for the leaf node associated with thread number 2. As we’ve seen before, we can count the bits after the third one in the bitfield and compute the node index that way, but that’s terribly inefficient because we’ll have to scan the entire bitfield from the start. For a tree of depth 25 that’s over 30 million bits.
This is the purpose of the sum reduction tree. It’s built by adding the value of each child pair and storing it in its parent from bottom to top. With this, you can do a binary search from top to bottom to find the node association much more efficiently.
So before each subdivision pass, the sum reduction tree has to be updated.</aside>

            </section>
    



    
        <section >
            
            <p><img src="Resources/BinarySearch_Example_02.png" alt=""></p>
<aside class="notes"> So moving forward with this example, the binary search works as follows. We have our thread index and start from the top of the tree.
We compare the thread index with the left child node and step to the left child as our thread index is smaller than that value.</aside>

            </section>
    



    
        <section >
            
            <p><img src="Resources/BinarySearch_Example_03.png" alt=""></p>
<aside class="notes"> Now we do the same again.</aside>

            </section>
    



    
        <section >
            
            <p><img src="Resources/BinarySearch_Example_04.png" alt=""></p>
<aside class="notes"> Compare the thread index with the left child. This time we step to the right child because our thread index is larger than the left child’s value.</aside>

            </section>
    



    
        <section >
            
            <p><img src="Resources/BinarySearch_Example_05.png" alt=""></p>
<aside class="notes"> When stepping to the right child, we subtract the left child’s value from our thread index. If you keep doing that until the value is smaller than 1, the node you end up on is the node associated with the thread index.
Compared to scanning the entire bitfield from the very start for each thread, this algorithm is much more efficient and has a better worst case performance cost.</aside>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-high-level-subdivision-code" class="anchor" href="#high-level-subdivision-code" aria-hidden="true"></a>High level Subdivision code</h4>
<pre><code>for(triangleIndex : triangles)
    nodeIndex = cbt.BinarySearch(triangleIndex);
    lod = ComputeLOD(GetTriangle(nodeIndex));
    if(lod &gt; 1.0f)
        cbt.Split(nodeIndex);
    else
        mergeTop = ComputeLOD(GetTriangle(TopTriangle)).x &lt; 1.0f;
        mergeBase = ComputeLOD(GetTriangle(BottomTriangle)).x &lt; 1.0f;
        if(mergeTop &amp;&amp; mergeBase)
            cbt.Merge(nodeIndex);
</code></pre>
<aside class="notes"> With these tools in mind, the whole subdivision eventually boils down to just a few simple operations. Each GPU thread takes a triangle by doing the binary search I’ve described, computes the LOD value based on user defined criteria such as camera distance, and either splits or merges the triangle based on that value.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-cbt--leb-update-loop" class="anchor" href="#cbt--leb-update-loop" aria-hidden="true"></a>CBT + LEB Update loop</h3>
<video src="Resources/renders/hq/UpdateFlow_Normal.mp4">
<aside class="notes"> So here are the high level stages that run per frame to perform the adaptive subdivision.
The indirect arguments are retrieved from the root node of the CBT which represent the amount of leaf nodes.
Then we can dispatch the exact amount of threads on the GPU to perform the subdivision. That’s followed by the sum reduction pass and then we can use that data to render our triangles.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-mesh-shader-loop" class="anchor" href="#mesh-shader-loop" aria-hidden="true"></a>Mesh Shader loop</h3>
<p>Subdivision + Rendering in a single shader!</p>
<p>Per triangle frustum culling and expansion.</p>
<video src="Resources/renders/hq/UpdateFlow_MeshShader.mp4">
<aside class="notes"> Not so long ago, GPU vendors have introduced so called mesh shaders. For the unfamiliar, these fancy new hipster shaders replace vertex shaders, geometry shaders and tessellation shaders including the fixed function input assembler. It allows you to implement it yourself using a compute shader-style interface. So instead of doing subdivision and rendering separately, you can implement the subdivision in an amplification shader and from within that shader, you can dispatch mesh shaders on the GPU to form triangles. Another advantage of mesh shaders is that they can produce extra triangles and remove triangles similar to geometry shaders without any of the downsides. This allows you to further subdivide each triangle from the CBT in even more triangles. In my implementation, I divide each triangle into 128 more triangles. The advantage of being able to remove triangles is that you can perform per triangle frustum culling to further reduce rendering cost.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-lod-criteria" class="anchor" href="#lod-criteria" aria-hidden="true"></a>LOD Criteria</h3>
<ul>
<li>Screen size</li>
<li>Frustum culling</li>
<li>Local displacement</li>
<li>Retain silhouette for shadows</li>
</ul>
<aside class="notes"> The subdivision algorithm allows you to make LOD decisions for each individual triangle. This can be completely arbitrary but I imagine most of the time the criteria are these. The idea is to keep the size of each triangle equal in size on screen. Meaning triangles far away from the view will be subdivides less. We can also stop subdividing triangles outside the view, and not subdivide in areas where we don’t need to. For the terrain example, we don’t have to subdivide areas where it’s completely flat.
We can compute these criteria per triangle on the GPU very efficiently and based on those metrics, you can decide if you want to split or merge the triangle.
Another interesting opportunity for research would be subdividing to retain just the silhouette when rendering shadow maps. Each view including shadows would need its own CBT so it can make its own subdivision decisions.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-storage" class="anchor" href="#storage" aria-hidden="true"></a>Storage</h3>
<p>Define max subdivision before hand.</p>
<span>
\[\begin{aligned}
VRAM = 2^{D+2}\, bits
\end{aligned} \]
</span>
<p>Grows exponentially</p>
<table>
<thead>
<tr>
<th>Depth</th>
<th>Size</th>
<th>Leaf nodes (Triangles)</th>
</tr>
</thead>
<tbody>
<tr>
<td>24</td>
<td>8.0 MB</td>
<td>8 388 608</td>
</tr>
<tr>
<td>25</td>
<td>16.0 MB</td>
<td>16 777 216</td>
</tr>
<tr>
<td>26</td>
<td>32.0 MB</td>
<td>33 554 432</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<aside class="notes"> The required storage for a CBT depends on its max depth and grows exponentially for each extra level due to its recursive nature. A tree with 25 nodes for example needs exactly 16 MB of memory and would mean more than 16 million leaf nodes when fully split.
The naive approach would be to store each node in an 32 bit integer but that would be extremely wasteful because for example the bitfield only needs a single bit per node. So more on that next.</aside>

            </section>
    



    
        <section >
            
            <h2><a id="user-content-packing-data" class="anchor" href="#packing-data" aria-hidden="true"></a>Packing Data</h2>
<p>We know exactly how many bits each node needs!</p>
<table>
<thead>
<tr>
<th>Depth</th>
<th>Bits/Node</th>
</tr>
</thead>
<tbody>
<tr>
<td>D</td>
<td>1 bit</td>
</tr>
<tr>
<td>D - 1</td>
<td>2 bits</td>
</tr>
<tr>
<td>D - 2</td>
<td>3 bits</td>
</tr>
<tr>
<td>D - 3</td>
<td>4 bits</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<aside class="notes"> An neat insight here, is the fact that we know exactly how many bits each node needs depending on its depth. The bottom level can only be either a 0 or a 1, so we only need 1 bit to represent that. The level above adds two 1 bit values together, so we only need 2 bit to represent that. The level above that adds 2 2 bit values together so we only need 3 bits for that. Doing this type of packing will exactly halve the memory cost of the tree.
However, we can’t simply modify certain bits in a datastream as all data is encoded in an array of 32 bit integers. Therefor, you have to compute the bit and elements offsets yourself and do some bit operations to set the right bit range. Because several GPU threads can access the same integers, all access to this data needs to be atomic.</aside>

            </section>
    



    
        <section >
            
            <h3><a id="user-content-whats-next" class="anchor" href="#whats-next" aria-hidden="true"></a>What’s next?</h3>
<ul>
<li>Unity’s future terrain rendering algorithm.</li>
<li>Suitable for water rendering?</li>
<li>More subdivision?</li>
<li>UE5’s Nanite</li>
</ul>
<p><img src="Resources/nanite.png" alt=""></p>
<aside class="notes"> So I think this technique is extremely promising and I’ve been surprised at how easy this all is to implement in practise be it either on the CPU or GPU. This algorithm will become Unity’s future terrain rendering algorithm and I wouldn’t be surprised if they’re experimenting with applying this to water rendering as well.
However, there’s still a desire to reach more subdivision without the great exponential memory and performance cost which I think will be very hard to solve. There are a few really clever tricks found to greatly optimize certain parts of this technique but there’s still a lot of work to be done.
Any time I read something about subdivision schemes for games, I’m always reminded by someone else asking how it compares and relates to Unreal Engine 5’s Nanite. I think the goal is the same being per pixel triangle detail for which it’s visually imperceptive to see LOD pops due to its subpixel property. And I think Nanite has solved the several major road blocks to achieve this while nobody came close before. Per pixel triangles are prohibilively expensive on today’s GPU’s due to its design and this subdivision scheme won’t even get close to Nanite without the software rasterization and compression that it has. However, Nanite does not support any form of runtime tessellation or displacement yet so in reality it can’t achieve this today.</aside>

            </section>
    



    
        <section >
            
            <ul>
<li><a href="http://advances.realtimerendering.com/">Advanced in Realtime Rendering 2021</a></li>
<li>Dupuy 2020 <a href="https://onrendering.com/data/papers/cbt/ConcurrentBinaryTrees.pdf">“Concurrent Binary Trees (with application to longest edge bisection)”</a></li>
<li>Dupuy 2021 <a href="https://www.youtube.com/watch?v=Wr3yIJ927EE">“Concurrent Binary Trees (paper presentation)”</a></li>
<li>Deliot and Yao 2021 <a href="http://advances.realtimerendering.com/s2021/Siggraph21%20Terrain%20Tessellation.pdf">“Experimenting with Concurrent Binary Trees for Large Scale Terrain Rendering”</a></li>
<li>Dupuy <a href="https://github.com/jdupuy/LongestEdgeBisection2D">Longest Edge Bisection demo on Github</a></li>
<li><a href="https://docs.manim.community/en/stable/index.html">Manim Community</a></li>
</ul>

            </section>
    



    
        <section >
            
            <h4><a id="user-content-source-code-in-github" class="anchor" href="#source-code-in-github" aria-hidden="true"></a>Source code in GitHub</h4>
<p><a href="http://github.com/simco50/D3D12_Research/tree/CBT">github.com/simco50/D3D12_Research/tree/CBT</a></p>

            </section>
    


    </div>


  </div>

  <script src="libs/reveal.js/3.8.0/lib/js/head.min.js"></script>
  <script src="libs/reveal.js/3.8.0/js/reveal.js"></script>

  <script>

    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({

        controls: true,
        controlsTutorial: true,
        controlsLayout: 'bottom-right',
        controlsBackArrows: 'faded',
        progress: true,
        slideNumber: true,
        history: true,
        keyboard: true,
        overview: true,
        center: true,
        touch: true,
        loop: false,
        rtl: false,
        shuffle: false,
        fragments: true,
        fragmentInURL: false,
        embedded: false,
        help: true,
        showNotes: false,
        autoPlayMedia: true,
        autoSlide: 0,
        autoSlideStoppable: true,
        autoSlideMethod: Reveal.navigateNext,
        defaultTiming: 120,
        mouseWheel: false,
        hideAddressBar: true,
        previewLinks: false,
        transition: 'none',
        transitionSpeed: 'default',
        backgroundTransition: 'default',
        viewDistance: 3,
        parallaxBackgroundImage: '',
        parallaxBackgroundSize: '',
        parallaxBackgroundHorizontal: 0,
        parallaxBackgroundVertical: 0,
        display: 'block',

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            // { src: 'libs/reveal.js/3.8.0/lib/js/classList.js', condition: function () { return !document.body.classList; } },
            // { src: 'libs/reveal.js/3.8.0/plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
            // { src: 'libs/reveal.js/3.8.0/plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
            // { src: 'libs/reveal.js/3.8.0/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
            { src: 'libs/reveal.js/3.8.0/plugin/notes/notes.js', async: true },
            { src: 'libs/reveal.js/3.8.0/plugin/chart/Chart.min.js' },
            { src: 'libs/reveal.js/3.8.0/plugin/chart/csv2chart.js' },
            { src: 'libs/reveal.js/3.8.0/plugin/embed-tweet/embed-tweet.js' },
            { src: 'libs/reveal.js/3.8.0/plugin/math/math.js', async: true },
            { src: 'libs/highlight.js/9.12.0/highlight.js', async: true },
            { src: 'libs/reveal.js/3.8.0/plugin/anything/anything.js' },
            { src: 'libs/reveal.js/3.8.0/plugin/mermaid/mermaid.min.js', async: true, callback: function() {mermaid.initialize({startOnLoad:false})} },	

           
        { src: 'libs/reveal.js/3.8.0/plugin/search/search.js', async: true },
           

           
        { src: 'libs/reveal.js/3.8.0/plugin/zoom-js/zoom.js', async: true },
            

            
        { src: 'libs/reveal.js/3.8.0/plugin/chalkboard/chalkboard.js' },
            

            
        { src: 'libs/reveal.js/3.8.0/plugin/menu/menu.js' },
            

            
        { src: 'libs/reveal.js/3.8.0/plugin/title-footer/title-footer.js', async: true, callback: function () { title_footer.initialize(); } },
            

        {
            src: 'libs/highlight.js/9.12.0/reveal-code-focus-1.0.0-mod.js',
            async: true,
            callback: function () {
                RevealCodeFocus();
            }
        },
            // { src: 'libs/reveal.js/3.8.0/plugin/reveal-code-focus/highlight.pack.js' },
            // { src: 'libs/reveal.js/3.8.0/plugin/reveal-code-focus/reveal-code-focus.js', async: true, callback: function() { RevealCodeFocus(); } },
           // {src: 'libs/reveal.js/3.8.0/plugin/line-numbers/line-numbers.js'}
        ]
        ,
    keyboard: {
        67: function () { RevealChalkboard.toggleNotesCanvas() },	// toggle notes canvas when 'c' is pressed
        66: function () { RevealChalkboard.toggleChalkboard() },	// toggle chalkboard when 'b' is pressed
        46: function () { RevealChalkboard.clear() },	// clear chalkboard when 'DEL' is pressed
        8: function () { RevealChalkboard.reset() },	// reset chalkboard data on current slide when 'BACKSPACE' is pressed
        68: function () { RevealChalkboard.download() },	// downlad recorded chalkboard drawing when 'd' is pressed
    },
    math: {
       // mathjax: 'libs/reveal.js/3.8.0/plugin/math/MathJax.js',
             mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
            config: 'TeX-AMS_HTML-full'
    },
    chart: {
        defaults: {
            global: {
                title: { fontColor: "#FFF" },
                legend: {
                    position: "bottom",
                        labels: { fontColor: "#FFF" },
                },
                tooltips: {
                    labels: { fontColor: "#FFF" },
                },
            },
            scale: {
                scaleLabel: { fontColor: "#FFF" },
                gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
                ticks: { fontColor: "#FFF" },
            }
        },
        line: { borderColor: ["rgba(20,220,220,.8)", "rgba(220,120,120,.8)", "rgba(20,120,220,.8)"], "borderDash": [[5, 10], [0, 0]] },
        bar: { backgroundColor: ["rgba(20,220,220,.8)", "rgba(220,120,120,.8)", "rgba(20,120,220,.8)"] },
        pie: { backgroundColor: [["rgba(0,0,0,.8)", "rgba(220,20,20,.8)", "rgba(20,220,20,.8)", "rgba(220,220,20,.8)", "rgba(20,20,220,.8)"]] },
        radar: { borderColor: ["rgba(20,220,220,.8)", "rgba(220,120,120,.8)", "rgba(20,120,220,.8)"] },
    },
    anything: [ 
	 {
	  className: "mermaid"
	 },
	 // ...
	],
    menu: {
        // Specifies which side of the presentation the menu will 
        // be shown. Use 'left' or 'right'.
        side: 'left',

            // Specifies the width of the menu.
            // Can be one of the following:
            // 'normal', 'wide', 'third', 'half', 'full', or
            // any valid css length value
            width: 'normal',

                // Add slide numbers to the titles in the slide list.
                // Use 'true' or format string (same as reveal.js slide numbers)
                numbers: false,

                    // Specifies which slide elements will be used for generating
                    // the slide titles in the menu. The default selects the first
                    // heading element found in the slide, but you can specify any
                    // valid css selector and the text from the first matching
                    // element will be used.
                    // Note: that a section data-menu-title attribute or an element
                    // with a menu-title class will take precedence over this option
                    titleSelector: 'h1, h2, h3, h4, h5, h6',

                        // If slides do not have a matching title, attempt to use the
                        // start of the text content as the title instead
                        useTextContentForMissingTitles: false,

                            // Hide slides from the menu that do not have a title.
                            // Set to 'true' to only list slides with titles.
                            hideMissingTitles: false,

                                // Adds markers to the slide titles to indicate the 
                                // progress through the presentation. Set to 'false'
                                // to hide the markers.
                                markers: true,

                                    // Specify custom panels to be included in the menu, by
                                    // providing an array of objects with 'title', 'icon'
                                    // properties, and either a 'src' or 'content' property.
                                    // custom: false,
                                    custom: [],
                                        // Specifies the themes that will be available in the themes
                                        // menu panel. Set to 'true' to show the themes menu panel
                                        // with the default themes list. Alternatively, provide an
                                        // array to specify the themes to make available in the
                                        // themes menu panel, for example...
                                        // [
                                        //     { name: 'Black', theme: 'css/theme/black.css' },
                                        //     { name: 'White', theme: 'css/theme/white.css' },
                                        //     { name: 'League', theme: 'css/theme/league.css' }
                                        // ]
                                        themes: false,

                                            // Specifies the path to the default theme files. If your
                                            // presentation uses a different path to the standard reveal
                                            // layout then you need to provide this option, but only
                                            // when 'themes' is set to 'true'. If you provide your own 
                                            // list of themes or 'themes' is set to 'false' the 
                                            // 'themesPath' option is ignored.
                                            themesPath: 'css/theme/',

                                                // Specifies if the transitions menu panel will be shown.
                                                // Set to 'true' to show the transitions menu panel with
                                                // the default transitions list. Alternatively, provide an
                                                // array to specify the transitions to make available in
                                                // the transitions panel, for example...
                                                // ['None', 'Fade', 'Slide']
                                                transitions: false,

                                                    // Adds a menu button to the slides to open the menu panel.
                                                    // Set to 'false' to hide the button.
                                                    openButton: true,

                                                        // If 'true' allows the slide number in the presentation to
                                                        // open the menu panel. The reveal.js slideNumber option must 
                                                        // be displayed for this to take effect
                                                        openSlideNumber: false,

                                                            // If true allows the user to open and navigate the menu using
                                                            // the keyboard. Standard keyboard interaction with reveal
                                                            // will be disabled while the menu is open.
                                                            keyboard: true,

                                                                // Normally the menu will close on user actions such as
                                                                // selecting a menu item, or clicking the presentation area.
                                                                // If 'true', the sticky option will leave the menu open
                                                                // until it is explicitly closed, that is, using the close
                                                                // button or pressing the ESC or m key (when the keyboard 
                                                                // interaction option is enabled).
                                                                sticky: false,

                                                                    // If 'true' standard menu items will be automatically opened
                                                                    // when navigating using the keyboard. Note: this only takes 
                                                                    // effect when both the 'keyboard' and 'sticky' options are enabled.
                                                                    autoOpen: true,

                                                                        // If 'true' the menu will not be created until it is explicitly
                                                                        // requested by calling RevealMenu.init(). Note this will delay
                                                                        // the creation of all menu panels, including custom panels, and
                                                                        // the menu button.
                                                                        delayInit: false,

                                                                            // If 'true' the menu will be shown when the menu is initialised.
                                                                            openOnInit: false,

                                                                                // By default the menu will load it's own font-awesome library
                                                                                // icons. If your presentation needs to load a different
                                                                                // font-awesome library the 'loadIcons' option can be set to false
                                                                                // and the menu will not attempt to load the font-awesome library.
                                                                                loadIcons: false
    },
    chalkboard: {
        toggleChalkboardButton: { left: "60px", bottom: "30px", top: "auto", right: "auto" },
        toggleNotesButton: { left: "90px", bottom: "30px", top: "auto", right: "auto" },

    }
    });



</script>
</body>

</html>